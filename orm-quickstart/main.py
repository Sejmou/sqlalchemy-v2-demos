from sqlalchemy.orm import Session
from sqlalchemy import select
from models import Base, User, Address
from sqlalchemy import create_engine

# the engine is used by the ORM to connect to the database
# depending on the type of connection string passed to create_engine, the ORM will use a different database backend
# by passing 'sqlite://', we are creating an in-memory SQLite database
# echo=True will print all SQL statements generated by the ORM. This is useful to understand how ORM queries are translated to SQL
engine = create_engine("sqlite://", echo=True)

Base.metadata.create_all(engine)


def add_users():
    with Session(engine) as session:
        spongebob = User(
            name="spongebob",
            fullname="Spongebob Squarepants",
            addresses=[Address(email_address="spongebob@sqlalchemy.org")],
        )
        sandy = User(
            name="sandy",
            fullname="Sandy Cheeks",
            addresses=[
                Address(email_address="sandy@sqlalchemy.org"),
                Address(email_address="sandy@squirrelpower.org"),
            ],
        )
        patrick = User(name="patrick", fullname="Patrick Star")
        session.add_all([spongebob, sandy, patrick])
        session.commit()


def print_spongebobs_and_sandys():
    """
    This example demonstrates how a SELECT ... WHERE statement can be formulated using the ORM to obtain User objects with the names "spongebob" and "sandy".

    Session.scalars() allows us to iterate over the results of the query and print the User objects.
    """
    with Session(engine) as session:
        stmt = select(User).where(User.name.in_(["spongebob", "sandy"]))
        for user in session.execute(stmt):
            print(user)


def print_sandys_sqlalchemy_email():
    """
    This example demonstrates the use of joins to combine data from multiple tables.

    We use the ORM to formulate an SQL `SELECT` statement that uses the `JOIN` clause to retrieve any Address object associated with the User object with the name "sandy" that ends with "@sqlalchemy.org".
    """
    with Session(engine) as session:
        sandys_id = session.execute(
            select(User.id).where(User.name == "sandy")
        ).scalar()
        if sandys_id is None:
            raise ValueError("User with name 'sandy' not found")
        stmt = (
            select(Address)
            .join(Address.user)
            .where(User.id == sandys_id)
            # we can just chain .where() calls to add more conditions to the WHERE clause (AND)
            .where(Address.email_address.like("%@sqlalchemy.org"))
        )
        sandy_address = session.scalars(stmt).one()
        print(sandy_address)


def add_email_to_patrick():
    """
    This example demonstrates how we can use the ORM to add an Address object to an existing User object with the name "patrick".

    Note that this will result in a total of 3 SQL statements being executed:
    1. A `SELECT` statement to retrieve the User with the name "patrick"
    2. A `SELECT` statement to retrieve the Address objects associated with the User object (this data is loaded 'lazily' by the ORM, i.e. only when it is accessed - see also: https://docs.sqlalchemy.org/en/20/glossary.html#term-lazy-load)
    3. An `INSERT` statement to add the new Address object to the database

    Note also that we have to commit the transaction to persist the changes to the database as otherwise any changes made to the database will be rolled back when the session is closed (i.e. we leave the `with Session(engine) as session` block).
    """
    with Session(engine) as session:
        patrick = session.execute(select(User).where(User.name == "patrick")).scalar()
        if patrick is None:
            raise ValueError("User with name 'patrick' not found")
        patrick.addresses.append(Address(email_address="patrickstar@sqlalchemy.org"))
        # NOTE: we have to commit the transaction to persist the changes to the database
        session.commit()


def get_email_addresses(username: str):
    """
    This example demonstrates how we can use the ORM to retrieve the email addresses associated with a User object with a given name.

    Note the use of .scalar_one() to retrieve a single result from the query. If the query returns no results or more than one result, or no results, an exception is raised.
    """
    with Session(engine) as session:
        user = session.execute(select(User).where(User.name == username)).scalar_one()
        return [address.email_address for address in user.addresses]


def main():
    actions = [
        ("adding users", add_users),
        (
            "printing users who are called 'spongebob' or 'sandy'",
            print_spongebobs_and_sandys,
        ),
        ("printing sandy's email", print_sandys_sqlalchemy_email),
        (
            "getting patrick's email addresses (before update)",
            lambda: print(get_email_addresses("patrick")),
        ),
        ("adding email to patrick", add_email_to_patrick),
        (
            "getting patrick's email addresses (after update)",
            lambda: print(get_email_addresses("patrick")),
        ),
    ]
    for description, action in actions:
        print(f"{description}...")
        action()
        print()


main()
